{
	"name": "detect-conflicts",
	"description": "Automatically detects and resolves merge conflicts with base branch before pushing",
	"hooks": [
		{
			"event": "PreToolUse",
			"matcher": {
				"tool": "Bash",
				"command": "git push"
			},
			"prompt": "Before pushing, check if this branch has merge conflicts with its base branch and automatically resolve them.\n\n## Pre-Check 1: Skip for Force Pushes\n\nFirst, check if this is a force push by looking for force push flags as standalone arguments (not as part of branch names). A command is a force push if it contains any of these as separate words/flags:\n- ` -f ` or ` -f` at end of command\n- `--force`\n- `--force-with-lease`\n\nDo NOT match `-f` when it appears as part of a branch name like `my-feature` or `fix-foo`. If it's a force push, skip all conflict resolution and let the push proceed.\n\n## Pre-Check 2: Skip if Merge/Rebase/Cherry-pick Already in Progress\n\nCheck if there's already an active merge, rebase, or cherry-pick:\n```bash\nif [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ] || [ -f .git/CHERRY_PICK_HEAD ]; then\n    echo \"Active merge/rebase/cherry-pick detected - skipping conflict check\"\nfi\n```\n\nIf any of these exist, **skip entirely** and let the push proceed (or fail naturally). Do NOT attempt to start a new merge or run `git merge --abort` as this would destroy the user's in-progress work.\n\n## Steps (only if NO force push AND NO active merge/rebase/cherry-pick)\n\n1. Get the current branch name:\n   ```bash\n   git branch --show-current\n   ```\n\n2. Determine the base branch (usually main or master):\n   ```bash\n   git remote show origin | grep 'HEAD branch' | cut -d' ' -f5\n   ```\n\n3. Fetch latest from remote:\n   ```bash\n   git fetch origin\n   ```\n\n4. Check if there would be conflicts by attempting a merge:\n   ```bash\n   git merge --no-commit --no-ff origin/<base> 2>&1\n   ```\n\n5. If conflicts are detected, resolve them automatically:\n   - For each conflicted file, read and analyze the conflicts\n   - Auto-resolve using these strategies:\n     - **Import conflicts**: Merge both import sets, deduplicate, sort\n     - **Whitespace/formatting**: Take the better formatted version\n     - **Non-overlapping additions**: Keep both in logical order\n     - **Deleted vs unchanged**: Prefer deletion if clearly cleanup; verify with tests\n     - **Both modified same logic**: Analyze intent, choose most complete version, verify with tests\n   - Edit each file to remove conflict markers with the resolved content\n   - Stage each resolved file individually: `git add <file>` (not `git add -A`)\n   - Verify no conflict markers remain in any text file:\n     ```bash\n     grep -rI \"<<<<<<<\" . --exclude-dir=.git --exclude-dir=node_modules --exclude-dir=dist --exclude-dir=build --exclude-dir=.next 2>/dev/null\n     ```\n   - Run tests if available - detect package manager by lock file (most specific first), and only run tests if a test script exists:\n     ```bash\n     # Detect package manager by lock file and check for test script\n     if [ -f bun.lockb ] || [ -f bun.lock ]; then\n         # Bun project - check if test script exists\n         if grep -q '\"test\"' package.json 2>/dev/null; then\n             bun test || { echo \"Tests failed\"; git merge --abort; exit 1; }\n         fi\n     elif [ -f pnpm-lock.yaml ]; then\n         # pnpm project\n         if grep -q '\"test\"' package.json 2>/dev/null; then\n             pnpm test || { echo \"Tests failed\"; git merge --abort; exit 1; }\n         fi\n     elif [ -f yarn.lock ]; then\n         # Yarn project\n         if grep -q '\"test\"' package.json 2>/dev/null; then\n             yarn test || { echo \"Tests failed\"; git merge --abort; exit 1; }\n         fi\n     elif [ -f package-lock.json ]; then\n         # npm project (must have lock file, not just package.json)\n         if grep -q '\"test\"' package.json 2>/dev/null; then\n             npm test || { echo \"Tests failed\"; git merge --abort; exit 1; }\n         fi\n     fi\n     # If no lock file or no test script, skip tests\n     ```\n   - If tests fail, abort with `git merge --abort` and let push proceed (conflicts will show on PR)\n   - If tests pass, complete the merge:\n     ```bash\n     git commit -m \"merge: resolve conflicts with <base>\"\n     ```\n   - Inform the user what was resolved (brief summary)\n\n6. If merge started but no conflicts:\n   ```bash\n   git commit -m \"merge: sync with <base>\"\n   ```\n\n7. If already up to date or no conflicts detected:\n   - Allow the push to proceed without interruption\n   - Do NOT output anything - stay silent\n\n## Resolution Guidelines\n\nWhen resolving conflicts, prefer:\n- The version with more complete functionality\n- The version that matches the project's existing patterns\n- The incoming (base branch) version for shared utilities/types that others depend on\n- The current branch version for feature-specific code\n\n## Aborting on Failure\n\nIf resolution fails or tests fail, abort the merge to restore clean state:\n```bash\ngit merge --abort\n```\nThis allows the push to proceed, and conflicts will appear on the PR instead.\n\n## Important\n\n- Skip entirely for force pushes (only match standalone flags: ` -f`, `--force`, `--force-with-lease`)\n- Skip entirely if merge/rebase/cherry-pick already in progress (don't destroy user's work)\n- Be fully automatic - do not ask the user for input\n- Only stage files that were actually conflicted (avoid staging untracked files)\n- Detect package manager by lock file (bun > pnpm > yarn > npm), require lock file presence\n- Only run tests if a test script exists in package.json\n- If tests fail, run `git merge --abort` before letting push proceed\n- Only inform the user what was resolved after the fact\n- Be silent when no conflicts exist"
		}
	]
}
