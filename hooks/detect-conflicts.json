{
	"name": "detect-conflicts",
	"description": "Automatically detects and resolves merge conflicts with base branch before pushing",
	"hooks": [
		{
			"event": "PreToolUse",
			"matcher": {
				"tool": "Bash",
				"command": "git push"
			},
			"prompt": "Before pushing, check if this branch has merge conflicts with its base branch and automatically resolve them.\n\n## Pre-Check: Skip for Force Pushes\n\nFirst, check if this is a force push. If the command contains `-f`, `--force`, or `--force-with-lease`, skip all conflict resolution and let the push proceed. Force pushes are typically used after rebasing where merge commits are not wanted.\n\n## Steps (only if NOT a force push)\n\n1. Get the current branch name:\n   ```bash\n   git branch --show-current\n   ```\n\n2. Determine the base branch (usually main or master):\n   ```bash\n   git remote show origin | grep 'HEAD branch' | cut -d' ' -f5\n   ```\n\n3. Fetch latest from remote:\n   ```bash\n   git fetch origin\n   ```\n\n4. Check if there would be conflicts by attempting a merge:\n   ```bash\n   git merge --no-commit --no-ff origin/<base> 2>&1\n   ```\n\n5. If conflicts are detected, resolve them automatically:\n   - For each conflicted file, read and analyze the conflicts\n   - Auto-resolve using these strategies:\n     - **Import conflicts**: Merge both import sets, deduplicate, sort\n     - **Whitespace/formatting**: Take the better formatted version\n     - **Non-overlapping additions**: Keep both in logical order\n     - **Deleted vs unchanged**: Prefer deletion if clearly cleanup; verify with tests\n     - **Both modified same logic**: Analyze intent, choose most complete version, verify with tests\n   - Edit each file to remove conflict markers with the resolved content\n   - Stage each resolved file individually: `git add <file>` (not `git add -A`)\n   - Verify no conflict markers remain in any text file:\n     ```bash\n     grep -rI \"<<<<<<<\" . --exclude-dir=.git --exclude-dir=node_modules --exclude-dir=dist --exclude-dir=build --exclude-dir=.next 2>/dev/null\n     ```\n   - Run tests if available and **check exit codes** (do NOT mask with `|| true`):\n     ```bash\n     if npm test 2>/dev/null; then\n         echo \"Tests passed\"\n     elif bun test 2>/dev/null; then\n         echo \"Tests passed\"\n     else\n         echo \"Tests failed - aborting merge\"\n         git merge --abort\n         # Report failure and let push proceed without merge\n     fi\n     ```\n   - If tests fail, abort with `git merge --abort` and let push proceed (conflicts will show on PR)\n   - If tests pass, complete the merge:\n     ```bash\n     git commit -m \"merge: resolve conflicts with <base>\"\n     ```\n   - Inform the user what was resolved (brief summary)\n\n6. If merge started but no conflicts:\n   ```bash\n   git commit -m \"merge: sync with <base>\"\n   ```\n\n7. If already up to date or no conflicts detected:\n   - Allow the push to proceed without interruption\n   - Do NOT output anything - stay silent\n\n## Resolution Guidelines\n\nWhen resolving conflicts, prefer:\n- The version with more complete functionality\n- The version that matches the project's existing patterns\n- The incoming (base branch) version for shared utilities/types that others depend on\n- The current branch version for feature-specific code\n\n## Aborting on Failure\n\nIf resolution fails or tests fail, abort the merge to restore clean state:\n```bash\ngit merge --abort\n```\nThis allows the push to proceed, and conflicts will appear on the PR instead.\n\n## Important\n\n- Skip entirely for force pushes (-f, --force, --force-with-lease)\n- Be fully automatic - do not ask the user for input\n- Only stage files that were actually conflicted (avoid staging untracked files)\n- Run tests and check exit codes - do NOT mask failures with `|| true`\n- If tests fail, run `git merge --abort` before letting push proceed\n- Only inform the user what was resolved after the fact\n- Be silent when no conflicts exist"
		}
	]
}
