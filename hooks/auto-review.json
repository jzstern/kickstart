{
	"name": "auto-review",
	"description": "Automatically reviews staged changes before commit and fixes any issues",
	"hooks": [
		{
			"event": "PreToolUse",
			"matcher": {
				"tool": "Bash",
				"command": "git commit"
			},
			"prompt": "A git commit is about to happen. Review the changes and fix any issues before the commit proceeds.\n\n## Pre-Check 1: Skip During Merge/Rebase/Cherry-pick\n\nFirst, check if there's an active merge, rebase, or cherry-pick:\n```bash\nif [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ] || [ -f .git/CHERRY_PICK_HEAD ]; then\n    echo \"Active merge/rebase/cherry-pick - skipping review\"\nfi\n```\n\nIf any of these exist, **skip entirely** and let the commit proceed. Do NOT modify merge resolution commits.\n\n## Pre-Check 2: Detect Commit Flags\n\nCheck if the command includes `-a` or `--all` flags (stages all modified tracked files at commit time). To do this, examine the commit command being run.\n\n## Review Process\n\n1. **Get changes to review**:\n   - If `-a` or `--all` flag is present: Run `git diff HEAD` (shows both staged and unstaged changes that will be committed)\n   - Otherwise: Run `git diff --cached` (shows only staged changes)\n\n2. **Skip if no changes**: If the diff is empty, output nothing and allow the commit\n\n3. **Review the changes** against these criteria:\n\n### Critical Issues (must fix)\n- Security vulnerabilities (path traversal, command injection, XSS, SQL injection)\n- Obvious bugs (undefined variable access, missing null checks that will crash)\n- Secrets or credentials in code\n\n### Warnings (should fix)\n- TypeScript `any` without justification comment\n- Missing error handling on async operations\n- Potential memory leaks (unsubscribed listeners, unclosed resources)\n\n### Skip (don't flag)\n- Style preferences\n- Minor refactoring opportunities\n- Missing tests\n- Documentation gaps\n- Naming conventions (handled by linters)\n\n## Action Required\n\n**If issues found:**\n1. Fix each issue by editing the relevant files (only files in the diff)\n2. Stage ONLY the specific files you edited: `git add <file>` for each file\n3. After staging, verify no scope expansion: run `git diff --cached --name-only` and confirm the file list matches what was originally staged plus your fixes\n4. Output a brief summary of what was fixed (one line per fix)\n5. The commit will then proceed with your fixes included\n\n**If no issues found:**\n- Output nothing (empty response)\n- The commit proceeds unchanged\n\n## Critical Safety Rules\n\n- **NEVER run `git commit`** - the original commit command will run after this hook completes\n- **NEVER modify files outside the staged/about-to-be-staged set**\n- **NEVER add new files** that weren't part of the original commit\n- **Keep fixes minimal** - fix only the specific issue, don't refactor surrounding code\n- **When uncertain, skip the fix** - let the code through rather than making a potentially wrong change\n- **Only stage files you edited** - use `git add <specific-file>` not `git add -A` or `git add .`"
		}
	]
}
