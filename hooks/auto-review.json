{
	"name": "auto-review",
	"description": "Automatically reviews staged changes before commit and fixes any issues",
	"hooks": [
		{
			"event": "PreToolUse",
			"matcher": {
				"tool": "Bash",
				"command": "git commit"
			},
			"prompt": "A git commit is about to happen. Review the changes and fix any issues before the commit proceeds.\n\n## Pre-Check 1: Skip During Merge/Rebase/Cherry-pick\n\nFirst, check if there's an active merge, rebase, or cherry-pick:\n```bash\nif [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ] || [ -f .git/CHERRY_PICK_HEAD ]; then\n    echo \"Active merge/rebase/cherry-pick - skipping review\"\nfi\n```\n\nIf any of these exist, **skip entirely** and let the commit proceed. Do NOT modify merge resolution commits.\n\n## Pre-Check 2: Detect `-a`/`--all` Flag\n\nDetermine if this is a `git commit -a` or `git commit --all` command. **Proper parsing is critical** to avoid false positives from commit messages.\n\nParsing rules:\n1. Split the command into arguments\n2. Only check arguments BEFORE any `-m`, `-F`, `-C`, `--message=`, `--file=`, or `--reuse-message=` option (these introduce message content)\n3. Look for `-a` or `--all` as standalone arguments, OR `-a` combined with other short flags (e.g., `-am` contains `-a`)\n4. Do NOT match `-a` inside quoted strings or message content\n\nExamples:\n- `git commit -a -m \"message\"` → HAS `-a` flag\n- `git commit -am \"message\"` → HAS `-a` flag (combined)\n- `git commit --all -m \"message\"` → HAS `--all` flag\n- `git commit -m \"remove -a option\"` → NO flag (it's in the message)\n- `git commit -m \"test\" -a` → NO flag (after message, would be invalid git syntax anyway)\n\nSet `HAS_ALL_FLAG=true` or `HAS_ALL_FLAG=false` based on this check.\n\n## Pre-Check 3: Identify Partially Staged Files (skip if HAS_ALL_FLAG)\n\n**Only perform this check if `HAS_ALL_FLAG=false`**. When `-a`/`--all` is used, all modified tracked files are committed anyway, so partial staging doesn't matter.\n\nIf `HAS_ALL_FLAG=false`, identify files with BOTH staged AND unstaged changes:\n```bash\n# Files with staged changes\ngit diff --cached --name-only > /tmp/staged_files\n# Files with unstaged changes  \ngit diff --name-only > /tmp/unstaged_files\n# Files in both lists are partially staged\ncomm -12 <(sort /tmp/staged_files) <(sort /tmp/unstaged_files)\n```\n\nFiles in both lists are \"partially staged\" (user used `git add -p`). Do NOT fix issues in these files.\n\n## Review Process\n\n1. **Get changes to review**:\n   - If `HAS_ALL_FLAG=true`: Run `git diff HEAD` (shows all changes that will be committed)\n   - If `HAS_ALL_FLAG=false`: Run `git diff --cached` (shows only staged changes)\n\n2. **Skip if no changes**: If the diff is empty, output nothing and allow the commit\n\n3. **Review the changes** against these criteria:\n\n### Critical Issues (must fix)\n- Security vulnerabilities (path traversal, command injection, XSS, SQL injection)\n- Obvious bugs (undefined variable access, missing null checks that will crash)\n- Secrets or credentials in code\n\n### Warnings (should fix)\n- TypeScript `any` without justification comment\n- Missing error handling on async operations\n- Potential memory leaks (unsubscribed listeners, unclosed resources)\n\n### Skip (don't flag)\n- Style preferences\n- Minor refactoring opportunities\n- Missing tests\n- Documentation gaps\n- Naming conventions (handled by linters)\n\n## Action Required\n\n**Determine if file is safe to fix:**\n- If `HAS_ALL_FLAG=true`: ALL files are safe to fix (no partial staging concern)\n- If `HAS_ALL_FLAG=false`: Only files NOT in the partially-staged list are safe to fix\n\n**If issues found in SAFE files:**\n1. Fix each issue by editing the relevant files (only files in the diff)\n2. Stage ONLY the specific files you edited: `git add <file>` for each file\n3. Output a brief summary of what was fixed (one line per fix)\n4. The commit will then proceed with your fixes included\n\n**If issues found in UNSAFE (partially staged) files:**\n1. Do NOT edit or fix these files\n2. Output a warning: \"[WARN] Issue in partially-staged file <filename>: <description> - skipping auto-fix to preserve staging scope\"\n3. Let the commit proceed with the issue unfixed\n\n**If no issues found:**\n- Output nothing (empty response)\n- The commit proceeds unchanged\n\n## Critical Safety Rules\n\n- **NEVER run `git commit`** - the original commit command will run after this hook completes\n- **NEVER fix issues in partially staged files** (when `HAS_ALL_FLAG=false`) - this would expand commit scope\n- **NEVER modify files outside the staged/about-to-be-staged set**\n- **NEVER add new files** that weren't part of the original commit\n- **Keep fixes minimal** - fix only the specific issue, don't refactor surrounding code\n- **When uncertain, skip the fix** - let the code through rather than making a potentially wrong change\n- **Only stage files you edited** - use `git add <specific-file>` not `git add -A` or `git add .`"
		}
	]
}
